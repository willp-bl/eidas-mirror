/*
 * Copyright (c) 2015 by European Commission
 *
 * Licensed under the EUPL, Version 1.1 or - as soon they will be approved by
 * the European Commission - subsequent versions of the EUPL (the "Licence");
 * You may not use this work except in compliance with the Licence.
 * You may obtain a copy of the Licence at:
 * http://www.osor.eu/eupl/european-union-public-licence-eupl-v.1.1
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the Licence is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the Licence for the specific language governing permissions and
 * limitations under the Licence.
 *
 * This product combines work with different licenses. See the "NOTICE" text
 * file for details on the various modules and licenses.
 * The "NOTICE" text file is part of the distribution. Any derivative works
 * that you distribute must include a readable copy of the "NOTICE" text file.
 *
 */

package eu.eidas.node.auth.connector;

import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import eu.eidas.auth.commons.*;
import eu.eidas.auth.commons.exceptions.*;
import eu.eidas.auth.engine.SAMLEngineUtils;
import eu.eidas.auth.engine.EIDASSAMLEngine;
import eu.eidas.auth.engine.metadata.MetadataProcessorI;
import eu.eidas.auth.engine.metadata.MetadataUtil;
import eu.eidas.engine.exceptions.SAMLEngineException;
import eu.eidas.engine.exceptions.EIDASSAMLEngineException;
import eu.eidas.impl.file.FileService;
import eu.eidas.node.ApplicationContextProvider;
import eu.eidas.node.auth.metadata.MetadataAgregator;
import eu.eidas.node.init.EidasSamlEngineFactory;
import eu.eidas.node.logging.LoggingMarkerMDC;
import eu.eidas.node.utils.EidasNodeErrorUtil;
import eu.eidas.node.utils.EidasNodeValidationUtil;
import eu.eidas.node.utils.PropertiesUtil;
import eu.eidas.node.utils.SessionHolder;

import org.apache.commons.lang.StringUtils;
import org.opensaml.saml2.core.Attribute;
import org.opensaml.saml2.metadata.IDPSSODescriptor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.MessageSource;
import org.springframework.context.NoSuchMessageException;

import javax.servlet.http.HttpSession;

/**
 * This class is used by {@link AUCONNECTOR} to get, process and generate SAML
 * Tokens.
 *
 * @see ICONNECTORSAMLService
 */
public final class AUCONNECTORSAML implements ICONNECTORSAMLService {

        /**
         * Logger object.
         */
        private static final Logger LOG = LoggerFactory.getLogger(AUCONNECTORSAML.class
                .getName());
        /**
         * Logger object.
         */
        private static final Logger logger = LoggerFactory.getLogger(AUCONNECTORSAML.class
                .getName());

    /**
     * Request logging.
     */
    private static final Logger LOGGER_COM_REQ = LoggerFactory
            .getLogger(EIDASValues.EIDAS_PACKAGE_REQUEST_LOGGER_VALUE.toString() + "."
                    + AUCONNECTOR.class.getSimpleName());

    /**
     * Response logging.
     */
    private static final Logger LOGGER_COM_RESP = LoggerFactory
            .getLogger(EIDASValues.EIDAS_PACKAGE_RESPONSE_LOGGER_VALUE.toString() + "."
                    + AUCONNECTOR.class.getSimpleName());

    /**
     * Logger bean.
     */
    private IEIDASLogger loggerBean;

    /**
     * SAML instance to communicate with SP.
     */
    private String samlSpInstance;

    /**
     * SAML instance to communicate with ServiceProxy.
     */
    private String samlServiceInstance;

    /**
     * Connector's processAuthenticationResponse class.
     */
    private AUCONNECTORUtil connectorUtil;

    /**
     * metadata url to be put in requests generated by the Connector module.
     */
    private String metadataUrl;

    /**
     * metadata url to be put in responses generated by the Connector module.
     */
    private String metadataResponderUrl;

    /**
     * Resource bundle to translate messages from ServiceProxy/VIdP.
     */
    private MessageSource messageSource;

    private boolean checkCitizenCertificateServiceCertificate;
    private EidasSamlEngineFactory samlEngineFactory;

    public void setCheckCitizenCertificateServiceCertificate(boolean checkCitizenCertificateServiceCertificate) {
        this.checkCitizenCertificateServiceCertificate = checkCitizenCertificateServiceCertificate;
    }
    public EidasSamlEngineFactory getSAMLEngineFactory() {
        return samlEngineFactory;
    }

    public void setSamlEngineFactory(EidasSamlEngineFactory samlEngineFactory) {
        this.samlEngineFactory = samlEngineFactory;
    }

    private MetadataProcessorI metadataProcessor;

    /**
     * {@inheritDoc}
     */
    public byte[] generateErrorAuthenticationResponse(final String inResponseTo,
                                                      final String issuer, final String destination, final String ipUserAddress,
                                                      final String statusCode, final String subCode, final String message) {
        EIDASSAMLEngine engine=null;
        try {
            engine = getSAMLEngineFactory().getEngine(samlSpInstance, getConnectorUtil() == null ? null : getConnectorUtil().getConfigs());
            // Generate SAMLResponse Fail.
            final EIDASAuthnRequest request = new EIDASAuthnRequest();
            request.setSamlId(inResponseTo);
            request.setIssuer(issuer);
            request.setAssertionConsumerServiceURL(destination);

            EIDASAuthnResponse samlResponseFail = new EIDASAuthnResponse();
            samlResponseFail.setStatusCode(statusCode);
            samlResponseFail.setSubStatusCode(subCode);
            samlResponseFail.setMessage(message);
            samlResponseFail.setIssuer(getConnectorResponderMetadataUrl());
            engine.setRequestIssuer(issuer);
            samlResponseFail = engine.generateEIDASAuthnResponseFail(request, samlResponseFail,
                            ipUserAddress, false);
            samlResponseFail.setInResponseTo(inResponseTo);
            prepareRespLoggerBean(EIDASValues.SP_RESPONSE.toString(),
                    samlResponseFail, inResponseTo);
            this.saveLog(AUCONNECTORSAML.LOGGER_COM_RESP);
            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "Connector - Generating ERROR SAML Response to request with ID {}, error is {} {}",
                    inResponseTo, statusCode, message);

            return samlResponseFail.getTokenSaml();
        } catch (final EIDASSAMLEngineException e) {
            LOG.info("BUSINESS EXCEPTION : Error generating SAMLToken", e);
            EidasNodeErrorUtil.processSAMLEngineException(e, LOG, getConnectorRedirectError(e, EIDASErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML));
            throw new InternalErrorEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML.errorMessage()), e);
        }finally {
            getSAMLEngineFactory().releaseEngine(engine);
        }
    }

    private EIDASErrors getConnectorRedirectError(EIDASSAMLEngineException exc, EIDASErrors defaultError){
        EIDASErrors redirectError=defaultError;
        EIDASErrors actualError=EIDASErrors.fromCode(exc.getErrorCode());
        if(actualError!=null && actualError.isShowToUser()){
            redirectError=actualError;
        }
        return redirectError;
    }

    /**
     * {@inheritDoc}
     */
    public byte[] getSAMLToken(final Map<String, String> parameters,
                               final String errorCode, final boolean isRequest) {

        String strSamlToken;
        String paramName;
        if (isRequest) {
            paramName = EIDASParameters.SAML_REQUEST.toString();
            strSamlToken = parameters.get(paramName);
        } else {
            paramName = EIDASParameters.SAML_RESPONSE.toString();
            strSamlToken = parameters.get(paramName);
        }
        validateParameter(paramName, strSamlToken, EIDASErrors.valueOf(errorCode));

        return EIDASUtil.decodeSAMLToken(strSamlToken);
    }

    public byte[] getSAMLArtifact(final Map<String, String> parameters,
                                  final String errorCode, final boolean isRequest){
        String paramName = EIDASParameters.SAML_ARTIFACT.toString();
        String strSamlArtifact = parameters.get(paramName);

        return EIDASUtil.decodeSAMLToken(strSamlArtifact);
    }

    /**
     * {@inheritDoc}
     */
    public EIDASAuthnRequest processAuthenticationRequest(final byte[] samlToken,
                                                          final Map<String, String> parameters) {
        EIDASSAMLEngine engine=null;
        try {

            engine = getSAMLEngineFactory().getEngine(samlSpInstance, getConnectorUtil() == null ? null : getConnectorUtil().getConfigs());
            // validate SAML Token
            final EIDASAuthnRequest authnRequest = engine.validateEIDASAuthnRequest(samlToken);

            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "Connector - Processing SAML Request with ID {}", authnRequest.getSamlId());

            LOG.trace("Validating parameters.");

            // Get Assertion Consumer URL and validate
            if(StringUtils.isEmpty(authnRequest.getAssertionConsumerServiceURL())){
                //retrieve it from the metadata
                authnRequest.setAssertionConsumerServiceURL(MetadataUtil.getAssertionUrlFromMetadata(metadataProcessor, engine, authnRequest));
            }
            validateParameter(EIDASParameters.SP_URL.toString(), authnRequest.getAssertionConsumerServiceURL(), EIDASErrors.SPROVIDER_SELECTOR_INVALID_SPREDIRECT);
            if(SessionHolder.getId()!=null){
                HttpSession session= SessionHolder.getId();
                session.setAttribute(EIDASParameters.SP_URL.toString(), authnRequest.getAssertionConsumerServiceURL());
                session.setAttribute(EIDASParameters.SAML_IN_RESPONSE_TO.toString(), authnRequest.getSamlId());
                session.setAttribute(EIDASParameters.ISSUER.toString(), authnRequest.getIssuer());
            }

            // Get Personal Attribute List and validate
            final IPersonalAttributeList pal = authnRequest.getPersonalAttributeList();
            validateParameter(EIDASParameters.ATTRIBUTE_LIST.toString(), pal.toString(), EIDASErrors.SPROVIDER_SELECTOR_INVALID_ATTR);

            // Get QAA Level and validate
            final String qaa = String.valueOf(authnRequest.getQaa());
            LOG.info("checking QAA {}{}"+ qaa);
            validateParameter(EIDASParameters.SP_QAALEVEL.toString(), qaa, EIDASErrors.SPROVIDER_SELECTOR_INVALID_SPQAA);

            parameters.put(EIDASParameters.EIDAS_SERVICE_LOA.toString(), authnRequest.getEidasLoA());

            // Get ProviderName and validate
            final String providerName = authnRequest.getProviderName();
            validateParameter(EIDASParameters.PROVIDER_NAME_VALUE.toString(), providerName, EIDASErrors.SPROVIDER_SELECTOR_INVALID_SP_PROVIDERNAME);
            parameters.put(EIDASParameters.PROVIDER_NAME_VALUE.toString(), providerName);

            // Alias validation : If alias is blank, then we continue the authentication flow
            aliasValidation(authnRequest, providerName);



            // Get SP ID (backwards compatibility)
            final String spId = StringUtils.isBlank(authnRequest.getSPID()) ? providerName : authnRequest.getSPID();

            validateParameter(EIDASParameters.SP_ID.toString(), spId, EIDASErrors.SPROVIDER_SELECTOR_INVALID_SPID);
            parameters.put(EIDASParameters.SP_ID.toString(), spId);

            final String serviceCode = getCountryCode(authnRequest, parameters);

            LOG.debug("Requested country: " + serviceCode);
            final String serviceURL = connectorUtil.loadConfigServiceURL(serviceCode);
            LOG.debug("Citizen Country URL " + serviceCode + " URL " + serviceURL);
            authnRequest.setCitizenCountryCode(serviceCode);
            if(connectorUtil.isEIDAS10(authnRequest.getMessageFormatName())){
                validateRequestLoA(authnRequest,connectorUtil.loadConfigServiceMetadataURL(serviceCode));
            } else if (connectorUtil.isEidasMessageSupportedOnly()){
                // Send an error SAML message back - the use of InvalidParameterEIDASException should have triggered an error page
                throw new InvalidParameterEIDASException(
                        EIDASUtil.getConfig(EIDASErrors.MESSAGE_FORMAT_UNSUPPORTED.errorCode()),
                        EIDASUtil.getConfig(EIDASErrors.MESSAGE_FORMAT_UNSUPPORTED.errorMessage()));
                
            }

            validateParameter(EIDASErrors.SERVICE_REDIRECT_URL.toString(), serviceURL, EIDASErrors.SPROVIDER_SELECTOR_INVALID_COUNTRY);

            LOG.trace("Checking if SP is reliable");
            parameters.put(EIDASParameters.SAML_IN_RESPONSE_TO.toString(), authnRequest.getSamlId());
            parameters.put(EIDASParameters.ISSUER.toString(), authnRequest.getIssuer());
            parameters.put(EIDASParameters.SP_URL.toString(), authnRequest.getAssertionConsumerServiceURL());
            parameters.put(EIDASParameters.SP_ID.toString(), spId);
            parameters.put(EIDASParameters.SP_QAALEVEL.toString(), qaa);

            // Validate if SP has valid qaalevel and is trustworthy
            if (!connectorUtil.validateSP(parameters)) {
                throw new InvalidParameterEIDASException(
                        EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SPQAAID
                                .errorCode()),
                        EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SPQAAID
                                .errorMessage()));
            }
            // check if SP is allowed to access requested attribute
            if (!connectorUtil.checkContents(spId, pal)) {
                LOG.info("ERROR : SP can't request this attrs");
                throw new SecurityEIDASException(
                        EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_SPNOTALLOWED
                                .errorCode()),
                        EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_SPNOTALLOWED
                                .errorMessage()));
            }
            if(parameters.containsKey(EIDASParameters.SP_METADATA_URL.toString()) && isIssuedBySelf(authnRequest) ){
                authnRequest.setIssuer(parameters.get(EIDASParameters.SP_METADATA_URL.toString()));
            }

            authnRequest.setDestination(serviceURL);

            // Checking for antiReplay
            if (!connectorUtil.checkNotPresentInCache(authnRequest.getSamlId(), authnRequest.getCitizenCountryCode())){
                LOG.trace("Eidas Audit");
                prepareReqLoggerBean(EIDASValues.SP_REQUEST.toString(), samlToken,
                        authnRequest, authnRequest.getSamlId());
                this.saveLog(AUCONNECTORSAML.LOGGER_COM_REQ);
                throw new SecurityEIDASException(
                        EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorCode()),
                        EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorMessage()));
            }

            //  Logging
            LOG.trace("Eidas Audit");
            prepareReqLoggerBean(EIDASValues.SP_REQUEST.toString(), samlToken, authnRequest, authnRequest.getSamlId());
            this.saveLog(AUCONNECTORSAML.LOGGER_COM_REQ);

            return authnRequest;
        } catch (final EIDASSAMLEngineException e) {
            // Special case for propagating the error in case of xxe
            EidasNodeErrorUtil.processSAMLEngineException(e, LOG, getConnectorRedirectError(e, EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML));
            throw new InternalErrorEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorMessage()), e);
        }finally {
            getSAMLEngineFactory().releaseEngine(engine);
        }
    }

    private void validateRequestLoA (EIDASAuthnRequest authRequest, String idpUrl){
        try{
            String colleagueLoA= SAMLEngineUtils.getServiceLoA(metadataProcessor.getEntityDescriptor(idpUrl));
            if(!StringUtils.isEmpty(colleagueLoA) && !EidasNodeValidationUtil.isRequestLoAValid(authRequest, colleagueLoA)){
                throw new InternalErrorEIDASException(
                        EIDASUtil.getConfig(EIDASErrors.SERVICE_PROVIDER_INVALID_LOA.errorCode()),
                        EIDASUtil.getConfig(EIDASErrors.SERVICE_PROVIDER_INVALID_LOA.errorMessage()));
            }
        }catch(SAMLEngineException exc){
            LOG.info("cannot retrieve metadata information {}", exc);
        }
    }
    private boolean isIssuedBySelf(EIDASAuthnRequest authnRequest){
        if(getConnectorMetadataUrl()!=null && getConnectorMetadataUrl().equalsIgnoreCase(authnRequest.getIssuer())) {
            return true;
        }
        return false;
    }
    /**
     * Alias validation : If alias is blank, then we continue the authentication flow: 
     * backwards compatibility!
     * @param authnRequest
     * @param providerName
     */
    private void aliasValidation(EIDASAuthnRequest authnRequest, String providerName) {
        final String alias = authnRequest.getAlias();
        LOG.trace("Alias validation!");
        if (StringUtils.isNotBlank(alias)
                && !StringUtils.lowerCase(providerName).equals(
                StringUtils.lowerCase(alias))
                && !connectorUtil.validateSPCertAlias(providerName, alias)) {

            LOG.info("ERROR : SP's (" + providerName + ") alias validation failed to "
                    + alias);
            throw new SecurityEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SPALIAS
                            .errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SPALIAS
                            .errorMessage()));
        }
        LOG.trace("Alias validation succeeded!");
    }

    /**
     * Gets the Country Code.
     *
     * @param authnRequest The Authentication Request object.
     * @param parameters   A map of necessary arguments.
     * @return the country code value.
     */
    private static String getCountryCode(final EIDASAuthnRequest authnRequest,
                                         final Map<String, String> parameters) {
        // Country: Mandatory if the destination is a ProxyService.
        String serviceCode;
        if (authnRequest.getCitizenCountryCode() == null) {
            serviceCode = parameters.get(EIDASParameters.COUNTRY.toString());
            authnRequest.setCitizenCountryCode(serviceCode);
        } else {
            serviceCode = authnRequest.getCitizenCountryCode();
        }

        // Compatibility
        if (serviceCode.endsWith(EIDASValues.EIDAS_SERVICE_SUFFIX.toString())) {
            serviceCode =
                    serviceCode.replace(EIDASValues.EIDAS_SERVICE_SUFFIX.toString(),
                            EIDASValues.EMPTY_STRING.toString());
        }
        return serviceCode;
    }

    /**
     * Checks if a given parameter and it's value aren't null and their size is
     * between the specified bounds.
     *
     * @param paramName  The name of the parameter to validate.
     * @param paramValue The value of the parameter to validate.
     * @param eidasError  The eidasERROR value.
     */
    private static void validateParameter(final String paramName,
                                          final String paramValue, final EIDASErrors eidasError) {
        EIDASUtil.validateParameter(AUCONNECTORSAML.class.getCanonicalName(), paramName,
                paramValue, EIDASUtil.getConfig(eidasError.errorCode()), EIDASUtil.getConfig(eidasError.errorMessage()));
    }

    /**
     * {@inheritDoc}
     */
    public EIDASAuthnRequest generateSpAuthnRequest(
            final EIDASAuthnRequest authData) {

        return generateAuthenticationRequest(samlSpInstance, authData);
    }

    /**
     * {@inheritDoc}
     */
    public EIDASAuthnRequest generateServiceAuthnRequest(
            final EIDASAuthnRequest authData) {

        final EIDASAuthnRequest retAuthData =
                generateAuthenticationRequest(samlServiceInstance, authData);

        if (retAuthData.getCitizenCountryCode() == null) {
            retAuthData.setCitizenCountryCode(authData.getCitizenCountryCode());
        }
        if (StringUtils.isEmpty(retAuthData.getCountry())) {
            retAuthData.setCountry(authData.getCountry());
        }
        prepareReqLoggerBean(EIDASValues.EIDAS_CONNECTOR_REQUEST.toString(),
                retAuthData.getTokenSaml(), retAuthData, authData.getSamlId());

        this.saveLog(AUCONNECTORSAML.LOGGER_COM_REQ);
        LOG.trace("Logging communication");

        return retAuthData;
    }

    private String extractErrorMessage(String defaultMsg, String errorCode){
        String newErrorMessage=defaultMsg;
        try {
            newErrorMessage =
                    messageSource.getMessage(errorCode, new Object[]{errorCode},
                            Locale.getDefault());
        }catch(NoSuchMessageException nsme){
            LOG.warn("Cannot found the message with the id {} - {}", errorCode, nsme);
        }
        return newErrorMessage;
    }
    /**
     * {@inheritDoc}
     */
    public EIDASAuthnRequest processAuthenticationResponse(
            final byte[] samlToken, final EIDASAuthnRequest authData,
            final EIDASAuthnRequest spAuthData, final String remoteAddr) {
        EIDASSAMLEngine engine=null;
        try {
            engine = getSAMLEngineFactory().getEngine(samlServiceInstance, getConnectorUtil() == null ? null : getConnectorUtil().getConfigs());
            Long serviceSkew = connectorUtil.loadConfigServiceTimeSkewInMillis(authData.getCitizenCountryCode());
            engine.initRequestedAttributes(authData.getPersonalAttributeList());
            final EIDASAuthnResponse authnResponse = engine.validateEIDASAuthnResponse(samlToken, remoteAddr, serviceSkew);

            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "Connector - Processing SAML Response to request with ID {}", authData.getSamlId());
            this.prepareRespLoggerBean(EIDASValues.EIDAS_CONNECTOR_RESPONSE.toString(),
                    authnResponse, spAuthData.getSamlId());
            this.saveLog(AUCONNECTORSAML.LOGGER_COM_RESP);

            LOG.trace("Checking inResponseTo");
            checkInResponseTo(authData.getSamlId(), authnResponse.getInResponseTo());

            checkAntiReplay(samlToken, authData, authnResponse);

            checkServiceCountryToCitizenCountry(samlToken, authData, authnResponse);

            if(!authnResponse.isFail()) {
                checkResponseLoA(samlToken, authData, authnResponse);
                authData.setEidasLoA(authnResponse.getAssuranceLevel());
            }

            LOG.trace("Checking status code");
            if (!EIDASStatusCode.SUCCESS_URI.toString().equals(
                    authnResponse.getStatusCode())) {
                LOG.info("ERROR : Auth not succeed!");

                final String errorCode =
                        EIDASUtil.getEidasErrorCode(authnResponse.getMessage());
                // We only change the error message if we get any error code on the Message!
                // Backwards compatibility
                String errorMessage = authnResponse.getMessage();
                if (StringUtils.isNotBlank(errorCode)) {
                    errorMessage=extractErrorMessage(errorMessage, errorCode);
                }
                final byte[] samlResponseFail =
                        generateErrorAuthenticationResponse(spAuthData.getSamlId(),
                                authData.getOriginalIssuer()!=null?authData.getOriginalIssuer():authData.getIssuer(), spAuthData.getAssertionConsumerServiceURL(),
                                remoteAddr, authnResponse.getStatusCode(),
                                authnResponse.getSubStatusCode(), errorMessage);
                throw new InternalErrorEIDASException(errorCode, errorMessage,
                        EIDASUtil.encodeSAMLToken(samlResponseFail));
            }

            LOG.trace("Checking audience...");
            checkAudienceRestriction(authData.getIssuer(), authnResponse.getAudienceRestriction());

            LOG.trace("Setting internal variables");

            authData.setPersonalAttributeList(authnResponse
                    .getPersonalAttributeList());
            if(authData.getOriginalIssuer()!=null) {
                spAuthData.setIssuer(authData.getOriginalIssuer());
            }
            return authData;
        } catch (final EIDASSAMLEngineException e) {
            LOG.info("BUSINESS EXCEPTION : SAML validation error", e.getMessage());
            LOG.debug("BUSINESS EXCEPTION : SAML validation error", e);
            EidasNodeErrorUtil.processSAMLEngineException(e, LOG, getConnectorRedirectError(e, EIDASErrors.COLLEAGUE_RESP_INVALID_SAML));
            //normal processing of the above line will already cause the throw of the below exception
            throw new InternalErrorEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.COLLEAGUE_RESP_INVALID_SAML.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.COLLEAGUE_RESP_INVALID_SAML
                            .errorMessage()), e);
        }finally{
            getSAMLEngineFactory().releaseEngine(engine);
        }
    }

    /**
     * Compares the stored SAML request id to the incoming SAML response id.
     *
     * @param auRequestID      The stored Id of the SAML request.
     * @param currentRequestId The Id of the incoming SAML response.
     */
    private void checkInResponseTo(final String auRequestID,
                                   final String currentRequestId) {

        if (auRequestID == null || !auRequestID.equals(currentRequestId)) {
            LOG.info(LoggingMarkerMDC.SECURITY_WARNING, "ERROR : Stored request Id ({}) is not the same than response request id ({})", auRequestID, currentRequestId);
            throw new InvalidSessionEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.AU_REQUEST_ID.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.AU_REQUEST_ID.errorMessage()));
        }
    }

    /**
     * Check if the citizen country code is the same than the Service signing certificate
     * @param samlToken     the samlToken received
     * @param authData      the initial authnRequest
     * @param authnResponse the authnResponse
     */
    private void checkServiceCountryToCitizenCountry(byte[] samlToken, EIDASAuthnRequest authData, EIDASAuthnResponse authnResponse) {
        if (checkCitizenCertificateServiceCertificate && !authData.getCitizenCountryCode().equals(authnResponse.getCountry())){
            LOG.warn("ERROR : Signing country for Service " + authnResponse.getCountry() + " is not the same than the citizen country code " + authData.getCitizenCountryCode());
            prepareReqLoggerBean(EIDASValues.SP_REQUEST.toString(), samlToken,
                    authData, authData.getSamlId());
            this.saveLog(AUCONNECTORSAML.LOGGER_COM_REQ);
            throw new InvalidSessionEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.INVALID_RESPONSE_COUNTRY_ISOCODE.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.INVALID_RESPONSE_COUNTRY_ISOCODE.errorMessage()));
        }
    }

    /**
     * check the LoA in the response against connector's own LoA
     * @param samlToken
     * @param authData
     * @param authnResponse
     */
    private void checkResponseLoA(byte[] samlToken, EIDASAuthnRequest authData, EIDASAuthnResponse authnResponse) {
        EidasLoaLevels requestedLevel=EidasLoaLevels.getLevel(authData.getEidasLoA());
        EidasLoaLevels responseLevel= EidasLoaLevels.getLevel(authnResponse.getAssuranceLevel());
        if (requestedLevel!=null && (responseLevel==null || !EidasNodeValidationUtil.isRequestLoAValid(authData, responseLevel.stringValue()))){
            LOG.info("ERROR : the level of assurance in the response "+authnResponse.getAssuranceLevel()+" does not satisfy the requested level "+requestedLevel);
            prepareReqLoggerBean(EIDASValues.SP_REQUEST.toString(), samlToken, authData, authData.getSamlId());
            this.saveLog(AUCONNECTORSAML.LOGGER_COM_REQ);
            throw new InvalidSessionEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.INTERNAL_ERROR.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.INTERNAL_ERROR.errorMessage()));
        }
    }

    /**
     * Check the antireplay cache to control if the samlId has not yet been submitted
     * @param samlToken     the samlToken received
     * @param authData      the initial authnRequest
     * @param authnResponse the authnResponse
     */
    private void checkAntiReplay(byte[] samlToken, EIDASAuthnRequest authData, EIDASAuthnResponse authnResponse) {
        if (!connectorUtil.checkNotPresentInCache(authnResponse.getSamlId(), authnResponse.getCountry())){
            LOG.info("ERROR : SAMLID " + authnResponse.getSamlId() + "+ for response found in Antireplay cache");
            prepareReqLoggerBean(EIDASValues.SP_REQUEST.toString(), samlToken,
                    authData, authData.getSamlId());
            this.saveLog(AUCONNECTORSAML.LOGGER_COM_REQ);
            throw new SecurityEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML.errorMessage()));
        }
    }

    /**
     * {@inheritDoc}
     */
    public byte[] generateAuthenticationResponse(
            final EIDASAuthnRequest authData, final String ipUserAddress) {
        EIDASSAMLEngine engine=null;
        try {
            engine = getSAMLEngineFactory().getEngine(samlSpInstance, getConnectorUtil() == null ? null : getConnectorUtil().getConfigs());

            EIDASAuthnResponse eidasResponse = new EIDASAuthnResponse();
            eidasResponse.setPersonalAttributeList(authData.getPersonalAttributeList());

            //TODO retrieve this from SP metadata
            boolean generateSignedAssertion = Boolean.parseBoolean(connectorUtil == null || connectorUtil.getConfigs() == null ? null : connectorUtil.getConfigs().getProperty(EIDASParameters.RESPONSE_SIGN_ASSERTION.toString()));
            engine.setRequestIssuer(authData.getIssuer());
            // Generate SAMLResponse.
            eidasResponse.setIssuer(getConnectorResponderMetadataUrl());
            if( StringUtils.isEmpty(authData.getEidasLoA()) && connectorUtil.isEIDAS10(authData.getMessageFormatName())){
                eidasResponse.setAssuranceLevel("dummy");
            }else{
//            	if (connectorUtil.isEidasMessageSupportedOnly()){
//                    // Send an error SAML message back - the use of InternalErrorEIDASException should have triggered an error page
//                    throw new InvalidParameterEIDASException(
//                            EIDASUtil.getConfig(EIDASErrors.MESSAGE_FORMAT_UNSUPPORTED.errorCode()),
//                            EIDASUtil.getConfig(EIDASErrors.MESSAGE_FORMAT_UNSUPPORTED.errorMessage()));
//                }
                eidasResponse.setAssuranceLevel(authData.getEidasLoA());
            }
            eidasResponse = engine.generateEIDASAuthnResponse(authData, eidasResponse,
                            ipUserAddress, false, generateSignedAssertion);

            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "Connector - Generating SAML Response to request with ID {}", authData.getSamlId());
            eidasResponse.setInResponseTo(authData.getSamlId());
            prepareRespLoggerBean(EIDASValues.SP_RESPONSE.toString(), eidasResponse,
                    authData.getSamlId());
            AUCONNECTORSAML.LOGGER_COM_RESP.info(LoggingMarkerMDC.SAML_EXCHANGE, loggerBean.toString());

            return eidasResponse.getTokenSaml();
        } catch (final EIDASSAMLEngineException e) {
            LOG.info("ERROR : Error generating SAMLToken", e);
            EidasNodeErrorUtil.processSAMLEngineException(e, LOG, getConnectorRedirectError(e, EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML));
            throw new InternalErrorEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.CONNECTOR_SAML_RESPONSE.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.CONNECTOR_SAML_RESPONSE.errorMessage()), e);
        }finally {
            if(engine!=null) {
                getSAMLEngineFactory().releaseEngine(engine);
            }
        }

    }

    /**
     * Generates a request SAML token based on an authentication request.
     *
     * @param instance String containing the SAML configuration to load.
     * @param authData An authentication request to generate the SAML token.
     * @return An authentication request with the embedded SAML token.
     * @see EIDASAuthnRequest
     */
    private EIDASAuthnRequest generateAuthenticationRequest(
            final String instance, final EIDASAuthnRequest authData) {

        final EIDASSAMLEngine engine = getSAMLEngineFactory().getEngine(instance, getConnectorUtil()==null?null:getConnectorUtil().getConfigs());

        try {

            // If there is no SP Country, Then we get it from SAML's Certificate
            if (StringUtils.isBlank(authData.getSpCountry())) {
                authData.setSpCountry(authData.getCountry());
            }
            LOG.info(LoggingMarkerMDC.SAML_EXCHANGE, "Connector - Processing SAML Request with ID {}", authData.getSamlId());
            if(getConnectorMetadataUrl()!=null && !getConnectorMetadataUrl().isEmpty() && PropertiesUtil.isMetadataEnabled()){
                authData.setOriginalIssuer(authData.getIssuer());
                authData.setIssuer(getConnectorMetadataUrl());
            }
            if(connectorUtil.isEIDAS10(authData.getMessageFormatName())){
                authData.setBinding(EIDASAuthnRequest.BINDING_EMPTY);
            }else if (connectorUtil.isEidasMessageSupportedOnly()){
                // Send an error SAML message back - the use of InternalErrorEIDASException should have triggered an error page
                throw new InvalidParameterEIDASException(
                        EIDASUtil.getConfig(EIDASErrors.MESSAGE_FORMAT_UNSUPPORTED.errorCode()),
                        EIDASUtil.getConfig(EIDASErrors.MESSAGE_FORMAT_UNSUPPORTED.errorMessage()));
            }

            return engine.generateEIDASAuthnRequest(authData);

        } catch (final EIDASSAMLEngineException e) {
            LOG.info(instance + " : Error generating SAML Token", e.getMessage());
            LOG.debug(instance + " : Error generating SAML Token", e);
            EidasNodeErrorUtil.processSAMLEngineException(e, LOG, getConnectorRedirectError(e, EIDASErrors.SPROVIDER_SELECTOR_INVALID_SAML));
            throw new InternalErrorEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.SPROVIDER_SELECTOR_ERROR_CREATE_SAML.errorMessage()), e);
        }finally {
            getSAMLEngineFactory().releaseEngine(engine);
        }
    }

    /**
     * Sets all the fields to audit the request.
     *
     * @param opType       The operation type.
     * @param samlObj      The SAML token byte[].
     * @param authnRequest The Authentication Request object.
     * @param spSamlId     The SP's SAML ID.
     * @see EIDASAuthnRequest
     */
    private void prepareReqLoggerBean(final String opType, final byte[] samlObj,
                                      final EIDASAuthnRequest authnRequest, final String spSamlId) {
        final String hashClassName=getConnectorUtil()!=null && getConnectorUtil().getConfigs()!=null?getConnectorUtil().getConfigs().getProperty(EIDASParameters.HASH_DIGEST_CLASS.toString()):null;
        final byte[] tokenHash = EIDASUtil.hashPersonalToken(samlObj, hashClassName);
        loggerBean.setTimestamp(DateUtil.currentTimeStamp().toString());
        loggerBean.setOpType(opType);
        loggerBean.setOrigin(authnRequest.getAssertionConsumerServiceURL());
        loggerBean.setDestination(authnRequest.getDestination());
        loggerBean.setSpApplication(authnRequest.getSpApplication());
        loggerBean.setProviderName(authnRequest.getProviderName());
        loggerBean.setCountry(authnRequest.getCitizenCountryCode());
        loggerBean.setQaaLevel(authnRequest.getQaa());
        loggerBean.setSamlHash(tokenHash);
        loggerBean.setSPMsgId(spSamlId);
        loggerBean.setMsgId(authnRequest.getSamlId());
    }

    /**
     * Sets all the fields to the audit the response.
     *
     * @param opType            The Operation Type.
     * @param authnResponse     The Authentication Response object.
     * @param inResponseToSPReq The SP's SAML Id.
     * @see EIDASAuthnRequest
     */
    private void prepareRespLoggerBean(final String opType,
                                       final EIDASAuthnResponse authnResponse, final String inResponseToSPReq) {
        final String hashClassName=getConnectorUtil()!=null && getConnectorUtil().getConfigs()!=null?getConnectorUtil().getConfigs().getProperty(EIDASParameters.HASH_DIGEST_CLASS.toString()):null;
        final byte[] tokenHash =
                EIDASUtil.hashPersonalToken(authnResponse.getTokenSaml(), hashClassName);
        final String message =
                EIDASValues.SUCCESS.toString() + EIDASValues.EID_SEPARATOR.toString()
                        + EIDASValues.CITIZEN_CONSENT_LOG.toString();
        loggerBean.setTimestamp(DateUtil.currentTimeStamp().toString());
        loggerBean.setOpType(opType);
        loggerBean.setInResponseTo(authnResponse.getInResponseTo());
        loggerBean.setInResponseToSPReq(inResponseToSPReq);
        loggerBean.setMessage(message);
        loggerBean.setSamlHash(tokenHash);
        loggerBean.setMsgId(authnResponse.getSamlId());
    }

    /**
     * Logs the transaction with the Audit log.
     *
     * @param logger The Audit Logger.
     */
    public void saveLog(final Logger logger) {
        logger.info(LoggingMarkerMDC.SAML_EXCHANGE, loggerBean.toString());
    }

    /**
     * Setters and getters
     */

    /**
     * Setter for loggerBean.
     *
     * @param nLoggerBean The loggerBean to set.
     * @see IEIDASLogger
     */
    public void setLoggerBean(final IEIDASLogger nLoggerBean) {
        this.loggerBean = nLoggerBean;
    }

    /**
     * Getter for loggerBean.
     *
     * @return The loggerBean value.
     * @see IEIDASLogger
     */
    public IEIDASLogger getLoggerBean() {
        return loggerBean;
    }

    /**
     * Compares the issuer to the audience restriction.
     *
     * @param issuer   The stored SAML request issuer.
     * @param audience The SAML response audience.
     */
    private void checkAudienceRestriction(final String issuer,
                                          final String audience) {

        if (issuer == null || !issuer.equals(audience)) {
            LOG.info("ERROR : Audience is null or not valid");
            throw new InvalidSessionEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.AUDIENCE_RESTRICTION.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.AUDIENCE_RESTRICTION.errorMessage()));
        }
    }

    /**
     * {@inheritDoc}
     */
    public void checkMandatoryAttributes(final EIDASAuthnRequest authnData,
                                         final String ipUserAddress) {

        if (authnData==null || !AttributeUtil.checkMandatoryAttributes(authnData.getPersonalAttributeList())) {
            LOG.info("BUSINESS EXCEPTION : Mandatory attribute is missing!");
            String errorMessage =
                    messageSource.getMessage(EIDASUtil.getConfig(EIDASErrors.ATT_VERIFICATION_MANDATORY.errorCode()),
                            new Object[]{EIDASUtil.getConfig(EIDASErrors.ATT_VERIFICATION_MANDATORY.errorCode())},
                            Locale.getDefault());
            final byte[] error =
                    generateErrorAuthenticationResponse(authnData.getSamlId(),
                            authnData.getIssuer(), authnData.getAssertionConsumerServiceURL(),
                            ipUserAddress, EIDASUtil.getConfig(EIDASErrors.ATT_VERIFICATION_MANDATORY.errorCode()),
                            EIDASSubStatusCode.REQUEST_DENIED_URI.toString(), errorMessage);
            if (LOG.isInfoEnabled()){
                LOG.info("Missing attributes: " + AttributeUtil.getMissingMandatoryAttributes(authnData.getPersonalAttributeList()));
            }
            throw new InternalErrorEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.ATT_VERIFICATION_MANDATORY.errorCode()),
                    errorMessage,
                    EIDASUtil.encodeSAMLToken(error));
        }
    }

    public void filterServiceSupportedAttrs (final EIDASAuthnRequest authnData, Map<String, String> parameters){
        final String serviceCode = getCountryCode(authnData, parameters);
        String serviceMetadataURL=getConnectorUtil().loadConfigServiceMetadataURL(serviceCode);
        if(StringUtils.isEmpty(serviceMetadataURL)){
            LOG.info("The service metadata  for"+serviceCode+" is not configured, unable to determine the supported attributes");
            return;
        }
        EIDASSAMLEngine engine=null;
        try {
            engine = getSAMLEngineFactory().getEngine(samlSpInstance, getConnectorUtil() == null ? null : getConnectorUtil().getConfigs());
            metadataProcessor.checkValidMetadataSignature(serviceMetadataURL, engine);
            IDPSSODescriptor idp=metadataProcessor.getIDPSSODescriptor(serviceMetadataURL);
            List<PersonalAttribute> paToRemove=new ArrayList<PersonalAttribute>();
            List<String> supportedAttrNames=new ArrayList<String>();
            for(Attribute a: idp.getAttributes()){
                supportedAttrNames.add(a.getName());
            }
            IPersonalAttributeList attributeList = authnData.getPersonalAttributeList();
            for(PersonalAttribute pa: attributeList){
                if(!supportedAttrNames.contains(pa.getFullName())){
                    LOG.warn("removing attribute "+pa.getFullName());
                    paToRemove.add(pa);
                }
            }
            for(PersonalAttribute pa: paToRemove) {
                attributeList.remove(pa.getName());
            }
            authnData.setPersonalAttributeList(attributeList);
        }catch(SAMLEngineException e){
            LOG.info("Error filtering supported attributes {}", e);
            EidasNodeErrorUtil.processSAMLEngineException(e, LOG, EIDASErrors.SAML_ENGINE_NO_METADATA);
            throw new InternalErrorEIDASException(
                    EIDASUtil.getConfig(EIDASErrors.SAML_ENGINE_NO_METADATA.errorCode()),
                    EIDASUtil.getConfig(EIDASErrors.SAML_ENGINE_NO_METADATA.errorMessage()), e);
        }finally {
            getSAMLEngineFactory().releaseEngine(engine);
        }
    }
    /**
     * Setter for samlSpInstance.
     *
     * @param nSamlSpInstance The new SamlSpInstance value.
     */
    public void setSamlSpInstance(final String nSamlSpInstance) {
        this.samlSpInstance = nSamlSpInstance;
    }

    /**
     * Getter for samlSpInstance.
     *
     * @return The samlSpInstance value.
     */
    public String getSamlSpInstance() {
        return samlSpInstance;
    }

    /**
     * Setter for samlServiceInstance.
     *
     * @param samlServiceInstance The new samlServiceInstance value.
     */
    public void setSamlServiceInstance(final String samlServiceInstance) {
        this.samlServiceInstance = samlServiceInstance;
    }

    /**
     * Getter for samlServiceInstance.
     *
     * @return The samlServiceInstance value.
     */
    public String getSamlServiceInstance() {
        return samlServiceInstance;
    }

    /**
     * Setter for connectorUtil.
     *
     * @param connectorUtil The new connectorUtil value.
     * @see AUCONNECTORUtil
     */
    public void setConnectorUtil(final AUCONNECTORUtil connectorUtil) {
        this.connectorUtil = connectorUtil;
    }

    /**
     * Getter for connectorUtil.
     *
     * @return The connectorUtil value.
     * @see AUCONNECTORUtil
     */
    public AUCONNECTORUtil getConnectorUtil() {
        return connectorUtil;
    }

    /**
     * Getter for messageSource.
     *
     * @return The messageSource value.
     * @see MessageSource
     */
    public MessageSource getMessageSource() {
        return messageSource;
    }

    /**
     * Setter for messageSource.
     *
     * @param nMessageSource The new messageSource value.
     * @see MessageSource
     */
    public void setMessageSource(final MessageSource nMessageSource) {
        this.messageSource = nMessageSource;
    }

    @Override
    public String getMetadata() {
        return "toBeDone";
    }

    public String getConnectorMetadataUrl() {
        return metadataUrl;
    }

    public void setConnectorMetadataUrl(String metadaUrl) {
        this.metadataUrl = metadaUrl;
    }

    public MetadataProcessorI getMetadataProcessor() {
        return metadataProcessor;
    }

    public void setMetadataProcessor(MetadataProcessorI metadataProcessor) {
        this.metadataProcessor = metadataProcessor;
    }

    public String getConnectorResponderMetadataUrl() {
        return metadataResponderUrl;
    }

    public void setConnectorResponderMetadataUrl(String metadataResponderUrl) {
        this.metadataResponderUrl = metadataResponderUrl;
    }
}
